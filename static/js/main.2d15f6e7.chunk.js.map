{"version":3,"sources":["App.tsx","index.tsx"],"names":["GRID_WIDTH","cells","Array","GRID_HEIGHT","fill","undefined","map","val","idx","moveHead","position","direction","trueX","newPosition","length","randomFood","snake","nonSnakeCells","filter","item","includes","Math","floor","random","snakeHead","initialSnake","App","useState","touch","setTouch","paused","setPaused","gameOver","setGameOver","tick","setTick","setSnake","setDirection","food","setFood","score","speed","useEffect","body","head","newHead","newSnake","setTimeout","getAdjacentClass","next","indexOf","previous","id","onTouchStart","evt","touches","screenX","screenY","onTouchEnd","changedTouches","newDirection","touchX","touchY","abs","nextHead","tabIndex","onKeyDown","event","code","onBlur","onFocus","rest","className","style","height","width","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2d15f6e7.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\n\nconst GRID_WIDTH = 30;\nconst GRID_HEIGHT = 30;\n\nconst cells = new Array(GRID_HEIGHT * GRID_WIDTH).fill(undefined).map((val, idx) => idx);\n\ntype Direction = 'up' | 'down' | 'left' | 'right';\n\nconst moveHead = (position: number, direction: Direction) => {\n  const trueX = position % GRID_WIDTH;\n  \n  const steps = {\n    'up': -GRID_WIDTH,\n    'down': GRID_WIDTH,\n    'left': -1,\n    'right': 1,\n  };\n\n  const newPosition = position + steps[direction];\n\n  if (direction === 'left' && trueX === 0) {\n    return position + GRID_WIDTH - 1;\n  }\n  if (direction === 'right' && trueX === GRID_WIDTH - 1) {\n    return position - GRID_WIDTH + 1;\n  }\n  if (newPosition === cells.length + GRID_WIDTH) {\n    return 0;\n  }\n  if (newPosition < 0) {\n    return cells.length + newPosition;\n  }\n  if (newPosition > cells.length) {\n    return newPosition - cells.length;\n  }\n  \n  return newPosition;\n}\n\nconst randomFood = (snake: number[]) => {\n  const nonSnakeCells = cells.filter(item => !snake.includes(item));\n  const randomIndex = Math.floor(Math.random() * nonSnakeCells.length);\n  return nonSnakeCells[randomIndex];\n}\n\nconst snakeHead = (cells.length / 2) + (GRID_WIDTH / 2);\nconst initialSnake = [snakeHead - 4, snakeHead - 3, snakeHead - 2, snakeHead - 1, snakeHead];\n\nconst App = () => {\n  const [touch, setTouch] = useState<[number, number] | undefined>();\n  const [paused, setPaused] = useState(true);\n  const [gameOver, setGameOver] = useState(false);\n  const [tick, setTick] = useState(0);\n  const [snake, setSnake] = useState<number[]>(initialSnake);\n  const [direction, setDirection] = useState<Direction>('right');\n  const [food, setFood] = useState(randomFood(snake));\n  const score = snake.length - initialSnake.length;\n  const speed = 100 - (score < 90 ? snake.length : 90);\n\n  useEffect(() => {\n    if (paused) {\n      return;\n    }\n    const [tail, ...body] = snake;\n    const head = snake[snake.length - 1];\n    const newHead = moveHead(head, direction);\n    if (snake.includes(newHead)) {\n      setGameOver(true);\n      return;\n    }\n    if (newHead === food) {\n      const newSnake = [...snake, newHead];\n      setSnake(newSnake);\n      setFood(randomFood(newSnake));\n    } else {\n      setSnake([...body, newHead]);\n    }\n    setTimeout(() => setTick(tick + 1), speed);\n  }, [tick, paused]);\n\n  const restartGame = () => {\n    setTick(0);\n    setGameOver(false);\n    setSnake(initialSnake);\n    setFood(randomFood(initialSnake));\n    setDirection('right');\n  }\n\n  const handleKeyPress = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.code === 'KeyP') {\n      setPaused(true);\n      return;\n    }\n\n    const keyMap: { [key: string]: Direction } = {\n      'ArrowLeft': 'left',\n      'ArrowRight': 'right',\n      'ArrowDown': 'down',\n      'ArrowUp': 'up',\n      'KeyA': 'left',\n      'KeyD': 'right',\n      'KeyS': 'down',\n      'KeyW': 'up',\n    };\n    const newDirection = keyMap[event.code];\n    if (!newDirection) {\n      return;\n    }\n\n    const nextHead = moveHead(snake[snake.length - 1], newDirection);\n    if (snake.length > 1 && nextHead === snake[snake.length - 2]) {\n      // Don't allow the player to turn back on themselves\n      return;\n    }\n    setDirection(newDirection);\n  }\n\n  const getAdjacentClass = (val: number, next: boolean) => {\n    const idx = snake.indexOf(val);\n    if(next ? (snake.length - 1 === idx || idx === -1) : (idx === 0 || idx === -1)) {\n      return '';\n    }\n    const previous = snake[idx + (next ? 1 : -1)];\n    if (val - previous === -1 || val - previous === GRID_WIDTH - 1) {\n      return 'right';\n    }\n    if (val - previous === 1 || val - previous === -GRID_WIDTH + 1) {\n      return 'left';\n    }\n    if (val - previous === -GRID_WIDTH || val - previous === cells.length - GRID_WIDTH) {\n      return 'down';\n    }\n    if (val - previous === GRID_WIDTH || val - previous === -cells.length + GRID_WIDTH) {\n      return 'up';\n    }\n    return '';\n  }\n  return (\n    <div\n      id=\"page-container\"\n      onTouchStart={(evt) => {\n        if (evt.touches.length !== 1) {\n          setTouch(undefined);\n          return;\n        }\n        const { screenX, screenY } = evt.touches[0];\n        setTouch([screenX, screenY]);\n      }}\n      onTouchEnd={(evt) => {\n        if (evt.changedTouches.length !== 1 || !touch) {\n          return;\n        }\n        const [touchX, touchY] = touch;\n        const { screenX, screenY } = evt.changedTouches[0];\n        let newDirection: Direction;\n        if (Math.abs(screenX - touchX) > Math.abs(screenY - touchY)) {\n          if (screenX - touchX > 0) {\n            newDirection = 'right';\n          } else {\n            newDirection = 'left';\n          }\n        } else {\n          if (screenY - touchY > 0) {\n            newDirection = 'down';\n          } else {\n            newDirection = 'up';\n          }\n        }\n\n        const nextHead = moveHead(snake[snake.length - 1], newDirection);\n        if (snake.length > 1 && nextHead === snake[snake.length - 2]) {\n          // Don't allow the player to turn back on themselves\n          return;\n        }\n        setDirection(newDirection);\n      }}\n    >\n      <div\n        id=\"grid-container\"\n        tabIndex={0}\n        onKeyDown={handleKeyPress}\n        onBlur={() => setPaused(true)}\n        onFocus={() => setPaused(false)}\n      >\n        {\n          cells.map((val, idx, rest) => (\n            <div\n              key={val}\n              className={`\n                cell\n                ${snake.includes(idx) ? 'snake' : ''}\n                ${food === idx ? 'food' : ''}\n                ${getAdjacentClass(val, true)}\n                ${getAdjacentClass(val, false)}\n              `}\n              style={{\n                height: `${100 / GRID_HEIGHT}%`,\n                width: `${100 / GRID_WIDTH}%`,\n              }}\n            />\n          ))\n        }\n        <div id=\"score\">\n          <div>Current score: {score}</div>\n          { !paused && !gameOver && <div>Press P to pause</div> }\n        </div>\n        <div id=\"overlay\">\n          {\n            gameOver && !paused && (\n              <div>\n                <div>Game over</div>\n                <div onClick={restartGame}>Click here to restart</div>\n              </div>\n            )\n          }\n          {\n            !gameOver && paused && (\n              <div>\n                <div>Game paused</div>\n                <div onClick={() => setPaused(false)}>Click here to resume</div>\n              </div>\n            )\n          }\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}