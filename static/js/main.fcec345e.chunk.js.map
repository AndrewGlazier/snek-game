{"version":3,"sources":["App.tsx","index.tsx"],"names":["GRID_WIDTH","cells","Array","GRID_HEIGHT","fill","undefined","map","val","idx","moveHead","position","direction","trueX","newPosition","length","randomFood","snake","nonSnakeCells","filter","item","includes","Math","floor","random","snakeHead","initialSnake","App","useState","touch","setTouch","paused","setPaused","gameOver","setGameOver","tick","setTick","setSnake","setDirection","food","setFood","score","speed","useEffect","body","head","newHead","newSnake","setTimeout","getAdjacentClass","next","indexOf","previous","id","onTouchStart","evt","touches","screenX","screenY","onTouchEnd","changedTouches","newDirection","touchX","touchY","abs","nextHead","tabIndex","onKeyDown","event","code","onBlur","onFocus","rest","className","style","height","width","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fcec345e.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport './App.css';\r\n\r\nconst GRID_WIDTH = 30;\r\nconst GRID_HEIGHT = 30;\r\n\r\nconst cells = new Array(GRID_HEIGHT * GRID_WIDTH).fill(undefined).map((val, idx) => idx);\r\n\r\ntype Direction = 'up' | 'down' | 'left' | 'right';\r\n\r\nconst moveHead = (position: number, direction: Direction) => {\r\n  const trueX = position % GRID_WIDTH;\r\n  \r\n  const steps = {\r\n    'up': -GRID_WIDTH,\r\n    'down': GRID_WIDTH,\r\n    'left': -1,\r\n    'right': 1,\r\n  };\r\n\r\n  const newPosition = position + steps[direction];\r\n\r\n  if (direction === 'left' && trueX === 0) {\r\n    return position + GRID_WIDTH - 1;\r\n  }\r\n  if (direction === 'right' && trueX === GRID_WIDTH - 1) {\r\n    return position - GRID_WIDTH + 1;\r\n  }\r\n  if (newPosition === cells.length + GRID_WIDTH) {\r\n    return 0;\r\n  }\r\n  if (newPosition < 0) {\r\n    return cells.length + newPosition;\r\n  }\r\n  if (newPosition > cells.length) {\r\n    return newPosition - cells.length;\r\n  }\r\n  \r\n  return newPosition;\r\n}\r\n\r\nconst randomFood = (snake: number[]) => {\r\n  const nonSnakeCells = cells.filter(item => !snake.includes(item));\r\n  const randomIndex = Math.floor(Math.random() * nonSnakeCells.length);\r\n  return nonSnakeCells[randomIndex];\r\n}\r\n\r\nconst snakeHead = (cells.length / 2) + (GRID_WIDTH / 2);\r\nconst initialSnake = [snakeHead - 4, snakeHead - 3, snakeHead - 2, snakeHead - 1, snakeHead];\r\n\r\nconst App = () => {\r\n  const [touch, setTouch] = useState<[number, number] | undefined>();\r\n  const [paused, setPaused] = useState(true);\r\n  const [gameOver, setGameOver] = useState(false);\r\n  const [tick, setTick] = useState(0);\r\n  const [snake, setSnake] = useState<number[]>(initialSnake);\r\n  const [direction, setDirection] = useState<Direction>('right');\r\n  const [food, setFood] = useState(randomFood(snake));\r\n  const score = snake.length - initialSnake.length;\r\n  const speed = 100 - (score < 90 ? snake.length : 90);\r\n\r\n  useEffect(() => {\r\n    if (paused || gameOver) {\r\n      return;\r\n    }\r\n    const [tail, ...body] = snake;\r\n    const head = snake[snake.length - 1];\r\n    const newHead = moveHead(head, direction);\r\n    if ((newHead === food ? snake : body).includes(newHead)) {\r\n      setGameOver(true);\r\n      return;\r\n    }\r\n    if (newHead === food) {\r\n      const newSnake = [...snake, newHead];\r\n      setSnake(newSnake);\r\n      setFood(randomFood(newSnake));\r\n    } else {\r\n      setSnake([...body, newHead]);\r\n    }\r\n    setTimeout(() => setTick(tick + 1), speed);\r\n  }, [tick, paused]);\r\n\r\n  const restartGame = () => {\r\n    setTick(0);\r\n    setGameOver(false);\r\n    setSnake(initialSnake);\r\n    setFood(randomFood(initialSnake));\r\n    setDirection('right');\r\n  }\r\n\r\n  const handleKeyPress = (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n    if (event.code === 'KeyP') {\r\n      setPaused(true);\r\n      return;\r\n    }\r\n\r\n    const keyMap: { [key: string]: Direction } = {\r\n      'ArrowLeft': 'left',\r\n      'ArrowRight': 'right',\r\n      'ArrowDown': 'down',\r\n      'ArrowUp': 'up',\r\n      'KeyA': 'left',\r\n      'KeyD': 'right',\r\n      'KeyS': 'down',\r\n      'KeyW': 'up',\r\n    };\r\n    const newDirection = keyMap[event.code];\r\n    if (!newDirection) {\r\n      return;\r\n    }\r\n\r\n    const nextHead = moveHead(snake[snake.length - 1], newDirection);\r\n    if (snake.length > 1 && nextHead === snake[snake.length - 2]) {\r\n      // Don't allow the player to turn back on themselves\r\n      return;\r\n    }\r\n    setDirection(newDirection);\r\n  }\r\n\r\n  const getAdjacentClass = (val: number, next: boolean) => {\r\n    const idx = snake.indexOf(val);\r\n    if(next ? (snake.length - 1 === idx || idx === -1) : (idx === 0 || idx === -1)) {\r\n      return '';\r\n    }\r\n    const previous = snake[idx + (next ? 1 : -1)];\r\n    if (val - previous === -1 || val - previous === GRID_WIDTH - 1) {\r\n      return 'right';\r\n    }\r\n    if (val - previous === 1 || val - previous === -GRID_WIDTH + 1) {\r\n      return 'left';\r\n    }\r\n    if (val - previous === -GRID_WIDTH || val - previous === cells.length - GRID_WIDTH) {\r\n      return 'down';\r\n    }\r\n    if (val - previous === GRID_WIDTH || val - previous === -cells.length + GRID_WIDTH) {\r\n      return 'up';\r\n    }\r\n    return '';\r\n  }\r\n  return (\r\n    <div\r\n      id=\"page-container\"\r\n      onTouchStart={(evt) => {\r\n        if (evt.touches.length !== 1) {\r\n          setTouch(undefined);\r\n          return;\r\n        }\r\n        const { screenX, screenY } = evt.touches[0];\r\n        setTouch([screenX, screenY]);\r\n      }}\r\n      onTouchEnd={(evt) => {\r\n        if (evt.changedTouches.length !== 1 || !touch) {\r\n          return;\r\n        }\r\n        const [touchX, touchY] = touch;\r\n        const { screenX, screenY } = evt.changedTouches[0];\r\n        let newDirection: Direction;\r\n        if (Math.abs(screenX - touchX) > Math.abs(screenY - touchY)) {\r\n          if (screenX - touchX > 0) {\r\n            newDirection = 'right';\r\n          } else {\r\n            newDirection = 'left';\r\n          }\r\n        } else {\r\n          if (screenY - touchY > 0) {\r\n            newDirection = 'down';\r\n          } else {\r\n            newDirection = 'up';\r\n          }\r\n        }\r\n\r\n        const nextHead = moveHead(snake[snake.length - 1], newDirection);\r\n        if (snake.length > 1 && nextHead === snake[snake.length - 2]) {\r\n          // Don't allow the player to turn back on themselves\r\n          return;\r\n        }\r\n        setDirection(newDirection);\r\n      }}\r\n    >\r\n      <div\r\n        id=\"grid-container\"\r\n        tabIndex={0}\r\n        onKeyDown={handleKeyPress}\r\n        onBlur={() => setPaused(true)}\r\n        onFocus={() => setPaused(false)}\r\n      >\r\n        {\r\n          cells.map((val, idx, rest) => (\r\n            <div\r\n              key={val}\r\n              className={`\r\n                cell\r\n                ${snake.includes(idx) ? 'snake' : ''}\r\n                ${food === idx ? 'food' : ''}\r\n                ${getAdjacentClass(val, true)}\r\n                ${getAdjacentClass(val, false)}\r\n              `}\r\n              style={{\r\n                height: `${100 / GRID_HEIGHT}%`,\r\n                width: `${100 / GRID_WIDTH}%`,\r\n              }}\r\n            />\r\n          ))\r\n        }\r\n        <div id=\"score\">\r\n          <div>Current score: {score}</div>\r\n          { !paused && !gameOver && <div>Press P to pause</div> }\r\n        </div>\r\n        <div id=\"overlay\">\r\n          {\r\n            gameOver && !paused && (\r\n              <div>\r\n                <div>Game over</div>\r\n                <div onClick={restartGame}>Click here to restart</div>\r\n              </div>\r\n            )\r\n          }\r\n          {\r\n            !gameOver && paused && (\r\n              <div>\r\n                <div>Game paused</div>\r\n                <div onClick={() => setPaused(false)}>Click here to resume</div>\r\n              </div>\r\n            )\r\n          }\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}